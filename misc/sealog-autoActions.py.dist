#!/usr/bin/env python3
#
# Purpose: This service listens for new events submitted to Sealog
#          and performs additional actions depending on the recieved
#          event.
#
#          This service listens for "Off deck" and "On deck"
#          milestones and enables/disables the ASNAP functionality
#          and if a lowering is currently active it will set the
#          start/stop time to the time of the event.
#
#          This service listens for "On bottom" and "Off bottom"
#          milestones and if a lowering is currently active it will
#          set the lowering_on_bottom/lowering_off_bottom milestone
#          times to the time of the event.
#
#   Usage: Type python3 sealog-autoActions.py to start the service.
#
#          This serivce runs in the forground. Type ^d to kill the service.
#
#  Author: Webb Pinner webbpinner@gmail.com
# Created: 2018-09-26
# Updated: 2020-01-27

import asyncio
import websockets
import json
import requests
import logging
import datetime
from pymongo import MongoClient

from python_sealog.custom_vars import getCustomVarUIDByName
from python_sealog.lowerings import getLoweringByEvent
from python_sealog.settings import apiServerURL, wsServerURL, headers, cruisesAPIPath, customVarAPIPath, eventsAPIPath, loweringsAPIPath

asnapStatusVarName = 'asnapStatus'
asnapStatusVarID = None

includeSet = ('VEHICLE')

clientWSID = 'autoActions'

hello = {
    'type': 'hello',
    'id': clientWSID,
    'auth': {
        'headers': headers
    },
    'version': '2',
    'subs': ['/ws/status/newEvents', '/ws/status/updateEvents']
}

ping = {
    'type':'ping',
    'id':clientWSID
}

auxDataTemplate = {
    'event_id': None,
    'data_source': None,
    'data_array': []
}

client = MongoClient()
db = client.datagrabberDB
collection = db.datagrabberCOLL

LOG_LEVEL = logging.INFO

# create logger
logger = logging.getLogger(__file__ )
logger.setLevel(LOG_LEVEL)

# create console handler and set level to debug
ch = logging.StreamHandler()
ch.setLevel(LOG_LEVEL)

# create formatter
formatter = logging.Formatter('%(asctime)s - %(name)s:%(lineno)s - %(levelname)s - %(message)s')

# add formatter to ch
ch.setFormatter(formatter)

# add ch to logger
logger.addHandler(ch)

async def autoActions():
  try:

    global asnapStatusVarID

    async with websockets.connect(wsServerURL) as websocket:

      await websocket.send(json.dumps(hello))

      while(True):

        event = await websocket.recv()
        eventObj = json.loads(event)

        if eventObj['type'] and eventObj['type'] == 'ping':
          await websocket.send(json.dumps(ping))

        elif eventObj['type'] and eventObj['type'] == 'pub':
          if eventObj['message']['event_value'] in includeSet:

            logger.debug("Event:\n" + json.dumps(eventObj['message'], indent=2))

            for option in eventObj['message']['event_options']:
              if option['event_option_name'] == "milestone" and option['event_option_value'] == "Off deck":
                logger.info("Turning on ASNAP")
                payload = { "custom_var_value": "On"}
                r = requests.patch(apiServerURL + customVarAPIPath + '/' + asnapStatusVarID, headers=headers, data = json.dumps(payload))

                lowering = getLoweringByEvent(eventObj['message']['id'])
                logger.debug("Lowering:\n" + json.dumps(lowering, indent=2))
                if not lowering:
                  logger.warning("Can't update lowering record because there is no lowering currently active")
                  continue

                logger.info("Setting start of lowering " + lowering['lowering_id'] + " to " + eventObj['message']['ts'])
                payload = { "start_ts": eventObj['message']['ts'] }
                r = requests.patch(apiServerURL + loweringsAPIPath + '/' + lowering['id'], headers=headers, data = json.dumps(payload))


              elif option['event_option_name'] == "milestone" and option['event_option_value'] == "On bottom":

                lowering = getLoweringByEvent(eventObj['message']['id'])
                logger.debug("Lowering:\n" + json.dumps(lowering, indent=2))
                if not lowering:
                  logger.warning("Can't update lowering record because there is no lowering currently active")
                  continue

                logger.info("Setting on bottom time of lowering " + lowering['lowering_id'] + " to " + eventObj['message']['ts'])
                payload = { "lowering_additional_meta": lowering['lowering_additional_meta'] }
                del payload['lowering_additional_meta']['lowering_files']
                
                if 'milestones' not in payload['lowering_additional_meta']:
                  payload['lowering_additional_meta']['milestones'] = { 'lowering_on_bottom': eventObj['message']['ts'] }
                else:
                  payload['lowering_additional_meta']['milestones']['lowering_on_bottom'] = eventObj['message']['ts']

                r = requests.patch(apiServerURL + loweringsAPIPath + '/' + lowering['id'], headers=headers, data = json.dumps(payload))



              elif option['event_option_name'] == "milestone" and option['event_option_value'] == "Off bottom":

                lowering = getLoweringByEvent(eventObj['message']['id'])
                logger.debug("Lowering:\n" + json.dumps(lowering, indent=2))
                if not lowering:
                  logger.warning("Can't update lowering record because there is no lowering currently active")
                  continue

                logger.info("Setting off bottom time of lowering " + lowering['lowering_id'] + " to " + eventObj['message']['ts'])
                payload = { "lowering_additional_meta": lowering['lowering_additional_meta'] }
                del payload['lowering_additional_meta']['lowering_files']
                
                if 'milestones' not in payload['lowering_additional_meta']:
                  payload['lowering_additional_meta']['milestones'] = { 'lowering_off_bottom': eventObj['message']['ts'] }
                else:
                  payload['lowering_additional_meta']['milestones']['lowering_off_bottom'] = eventObj['message']['ts']

                r = requests.patch(apiServerURL + loweringsAPIPath + '/' + lowering['id'], headers=headers, data = json.dumps(payload))



              elif option['event_option_name'] == "milestone" and option['event_option_value'] == "On deck":
                logger.info("Turning off ASNAP")
                payload = { "custom_var_value": "Off"}
                r = requests.patch(apiServerURL + customVarAPIPath + '/' + asnapStatusVarID, headers=headers, data = json.dumps(payload))

                lowering = getLoweringByEvent(eventObj['message']['id'])
                logger.debug("Lowering:\n" + json.dumps(lowering, indent=2))
                if not lowering:
                  logger.warning("Can't update lowering record because there is no lowering currently active")
                  continue

                logger.info("Setting stop time of lowering " + lowering['lowering_id'] + " to " + eventObj['message']['ts'])
                payload = { "stop_ts": eventObj['message']['ts'] }
                r = requests.patch(apiServerURL + loweringsAPIPath + '/' + lowering['id'], headers=headers, data = json.dumps(payload))

          else:
            logger.debug("Skipping because event value is not in the include set")

  except Exception as error:
    logging.error(str(error))


if __name__ == '__main__':

  import argparse
  import os
  import sys

  parser = argparse.ArgumentParser(description='Auto-Actions Service')
  parser.add_argument('-d', '--debug', action='store_true', help=' display debug messages')

  args = parser.parse_args()

  # Turn on debug mode
  if args.debug:
    logger.info("Setting log level to DEBUG")
    logger.setLevel(logging.DEBUG)
    for handler in logger.handlers:
      handler.setLevel(logging.DEBUG)
    logger.debug("Log level now set to DEBUG")
    
  # Retrieve the asnapStatus ID
  try:
    asnapStatusVarID = getCustomVarUIDByName(asnapStatusVarName)
  except Exception as error:
    logger.error("Error retrieving the asnapStatus ID")
    logger.error(str(error))

  # Run the main loop
  try:
    asyncio.get_event_loop().run_until_complete(autoActions())
  except KeyboardInterrupt:
    print('Interrupted')
    try:
      sys.exit(0)
    except SystemExit:
      os._exit(0)